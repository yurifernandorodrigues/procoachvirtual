"""
Bot do Discord do Treinador Virtual de LoL - Vers√£o Cloud

Esta vers√£o suporta:
- M√∫ltiplos servidores Discord simultaneamente
- Integra√ß√£o com WebSocket server para receber dados de clientes locais
- Sistema de tokens de autentica√ß√£o por usu√°rio
- Gerenciamento de estado por servidor (guild)
"""

import discord
from discord.ext import commands, tasks
import asyncio
import os
from pathlib import Path
from openai import OpenAI
from gtts import gTTS
import io
import sys
import requests
from typing import Dict

# Importar o servidor WebSocket
from websocket_server import WebSocketServer

# Importar m√≥dulos do treinador
sys.path.insert(0, os.path.dirname(__file__))
from analysis_and_tips_module_cloud import GameAnalyzer

# Configura√ß√£o do bot
intents = discord.Intents.default()
intents.message_content = True
intents.voice_states = True
intents.guilds = True
intents.members = True

bot = commands.Bot(command_prefix=\'!coach \', intents=intents)

# Chave da Riot API
RIOT_API_KEY = os.getenv("RIOT_API_KEY")

# Estado por servidor (guild)
class GuildState:
    def __init__(self, guild_id: int):
        self.guild_id = guild_id
        self.monitoring = False
        self.voice_client = None
        self.game_analyzer = GameAnalyzer()
        self.monitored_players = []
        self.last_tips = []
        self.audio_queue = asyncio.Queue()
        self.bot_name = "Treinador Virtual"
        self.text_channel = None  # Canal onde o bot foi ativado
        self.user_tokens = {}  # user_id -> token

# Dicion√°rio de estados por servidor
bot.guild_states: Dict[int, GuildState] = {}

# Servidor WebSocket
ws_server = None

def get_guild_state(guild_id: int) -> GuildState:
    """Obt√©m ou cria o estado para um servidor"""
    if guild_id not in bot.guild_states:
        bot.guild_states[guild_id] = GuildState(guild_id)
    return bot.guild_states[guild_id]

# Eventos do bot
@bot.event
async def on_ready():
    """Evento chamado quando o bot est√° pronto"""
    print(f"‚úÖ Bot conectado como {bot.user}")
    print(f"üìä Servidores: {len(bot.guilds)}")
    print(f"üîó Link de convite: https://discord.com/api/oauth2/authorize?client_id={bot.user.id}&permissions=3165184&scope=bot")
    
    # Inicializar estados para todos os servidores
    for guild in bot.guilds:
        get_guild_state(guild.id)
    
    # Iniciar o servidor WebSocket
    global ws_server
    ws_server = WebSocketServer(bot)
    asyncio.create_task(ws_server.start(host="0.0.0.0", port=8765))

@bot.event
async def on_guild_join(guild):
    """Evento chamado quando o bot entra em um novo servidor"""
    print(f"‚úÖ Bot adicionado ao servidor: {guild.name} (ID: {guild.id})")
    get_guild_state(guild.id)
    
    # Enviar mensagem de boas-vindas
    for channel in guild.text_channels:
        if channel.permissions_for(guild.me).send_messages:
            await channel.send(
                f"üëã Ol√°! Eu sou o **Treinador Virtual de League of Legends**!\n\n"
                f"Para come√ßar a usar, siga estes passos:\n"
                f"1. Use `!coach gettoken` para obter seu token de autentica√ß√£o\n"
                f"2. Baixe e execute o cliente local: [Link do Cliente (Em Breve)]\n"
                f"3. Entre em um canal de voz e use `!coach join`\n"
                f"4. Use `!coach start` para iniciar o monitoramento\n\n"
                f"Use `!coach help` para ver todos os comandos dispon√≠veis!"
            )
            break

@bot.event
async def on_guild_remove(guild):
    """Evento chamado quando o bot sai de um servidor"""
    print(f"‚ùå Bot removido do servidor: {guild.name} (ID: {guild.id})")
    if guild.id in bot.guild_states:
        del bot.guild_states[guild.id]

# Comandos do bot

@bot.command(name=\'gettoken\', help=\'Obt√©m seu token de autentica√ß√£o para o cliente local\')
async def get_token(ctx):
    """Gera e envia um token de autentica√ß√£o para o usu√°rio"""
    guild_state = get_guild_state(ctx.guild.id)
    
    # Gerar token
    token = ws_server.generate_token(ctx.author.id, ctx.guild.id, ctx.author.display_name)
    guild_state.user_tokens[ctx.author.id] = token
    
    # Enviar token via DM
    try:
        await ctx.author.send(
            f"üîë **Seu Token de Autentica√ß√£o**\n\n"
            f"```\n{token}\n```\n\n"
            f"‚ö†Ô∏è **Importante:**\n"
            f"- N√£o compartilhe este token com ningu√©m\n"
            f"- Use este token para configurar a vari√°vel de ambiente `USER_AUTH_TOKEN` no cliente local\n"
            f"- O token √© v√°lido por 30 dias\n\n"
            f"üì• **Como usar:**\n"
            f"1. Baixe o cliente local (link em breve)\n"
            f"2. Configure a vari√°vel `USER_AUTH_TOKEN` com este token\n"
            f"3. Execute o cliente local antes de jogar"
        )
        await ctx.send(f"‚úÖ {ctx.author.mention}, enviei seu token por mensagem privada!")
    except discord.Forbidden:
        await ctx.send(
            f"‚ùå {ctx.author.mention}, n√£o consegui enviar uma mensagem privada. "
            f"Por favor, habilite mensagens privadas de membros do servidor."
        )

@bot.command(name=\'join\', help=\'O bot entra no seu canal de voz\')
async def join(ctx):
    """Faz o bot entrar no canal de voz do usu√°rio"""
    guild_state = get_guild_state(ctx.guild.id)
    
    if not ctx.author.voice:
        await ctx.send("‚ùå Voc√™ precisa estar em um canal de voz!")
        return
    
    channel = ctx.author.voice.channel
    
    if guild_state.voice_client and guild_state.voice_client.is_connected():
        await guild_state.voice_client.move_to(channel)
    else:
        guild_state.voice_client = await channel.connect()
    
    await ctx.send(f"‚úÖ Conectado ao canal **{channel.name}**!")

@bot.command(name=\'leave\', help=\'O bot sai do canal de voz\')
async def leave(ctx):
    """Faz o bot sair do canal de voz"""
    guild_state = get_guild_state(ctx.guild.id)
    
    if guild_state.voice_client and guild_state.voice_client.is_connected():
        await guild_state.voice_client.disconnect()
        guild_state.voice_client = None
        await ctx.send("üëã Desconectado do canal de voz!")
    else:
        await ctx.send("‚ùå N√£o estou em nenhum canal de voz!")

@bot.command(name=\'start\', help=\'Inicia o monitoramento da partida\')
async def start_monitoring(ctx):
    """Inicia o monitoramento da partida"""
    guild_state = get_guild_state(ctx.guild.id)
    
    if guild_state.monitoring:
        await ctx.send("‚ö†Ô∏è O monitoramento j√° est√° ativo!")
        return
    
    guild_state.monitoring = True
    guild_state.text_channel = ctx.channel
    guild_state.last_tips = []
    
    await ctx.send(
        f"‚úÖ Monitoramento iniciado!\n\n"
        f"üì± **Certifique-se de que:**\n"
        f"1. O cliente local est√° rodando no seu computador\n"
        f"2. Voc√™ est√° em uma partida do League of Legends\n\n"
        f"üí° Vou fornecer dicas em tempo real via voz e texto!"
    )

@bot.command(name=\'stop\', help=\'Para o monitoramento da partida\')
async def stop_monitoring(ctx):
    """Para o monitoramento da partida"""
    guild_state = get_guild_state(ctx.guild.id)
    
    if not guild_state.monitoring:
        await ctx.send("‚ö†Ô∏è O monitoramento n√£o est√° ativo!")
        return
    
    guild_state.monitoring = False
    guild_state.last_tips = []
    
    await ctx.send("‚èπÔ∏è Monitoramento parado!")

@bot.command(name=\'setname\', help=\'Define um nome personalizado para o treinador\')
async def set_bot_name(ctx, *, new_name: str):
    """Define um nome personalizado para o treinador"""
    guild_state = get_guild_state(ctx.guild.id)
    guild_state.bot_name = new_name
    await ctx.send(f"‚úÖ Meu nome agora √© **{new_name}**! Prazer em conhec√™-lo, {ctx.author.display_name}.")

@bot.command(name=\'ask\', help=\'Faz uma pergunta ao treinador\')
async def ask(ctx, *, question: str):
    """Responde a uma pergunta do usu√°rio"""
    guild_state = get_guild_state(ctx.guild.id)
    await ctx.send("ü§î Pensando...")
    
    try:
        # Obter contexto do jogo do cliente local, se dispon√≠vel
        user_token = guild_state.user_tokens.get(ctx.author.id)
        game_data = ws_server.active_games.get(user_token) if user_token else None
        
        context = ""
        if game_data:
            active_player = game_data.get("activePlayer", {})
            player_list = game_data.get("allPlayers", [])
            game_stats = game_data.get("gameData", {})
            
            if active_player:
                context += f"O jogador ativo √© {active_player.get(\'summonerName\')} jogando com {active_player.get(\'championName\')}. "
                context += f"Ele est√° no n√≠vel {active_player.get(\'level\')} e tem {active_player.get(\'currentGold\')} de ouro. "
            if game_stats:
                context += f"O tempo de jogo atual √© de {game_stats.get(\'gameTime\')} segundos. "
            if player_list:
                context += f"Os campe√µes no jogo s√£o: {\', \'.join([p.get(\'championName\') for p in player_list])}. "
        
        # Preparar mensagem para o LLM
        openai_client = OpenAI()
        messages = [
            {"role": "system", "content": f"Voc√™ √© um treinador virtual de League of Legends chamado {guild_state.bot_name}. Forne√ßa dicas e responda a perguntas de forma √∫til e concisa, baseando-se no contexto do jogo fornecido. Use portugu√™s do Brasil. Mantenha um tom de coach profissional e encorajador. Ao se dirigir ao usu√°rio, use o nome dele: {ctx.author.display_name}."},
        ]
        if context:
            messages.append({"role": "system", "content": f"Contexto atual do jogo: {context}"})
        messages.append({"role": "user", "content": question})
        
        response = openai_client.chat.completions.create(
            model="gemini-2.5-flash",
            messages=messages,
            max_tokens=150
        )
        
        answer = response.choices[0].message.content
        
        # Enviar resposta no chat
        await ctx.send(f"üí° **{guild_state.bot_name} diz:**\n{answer}")
        
        # Se estiver em um canal de voz, tamb√©m falar a resposta
        if guild_state.voice_client and guild_state.voice_client.is_connected():
            await speak_text(guild_state, answer)
    
    except Exception as e:
        await ctx.send(f"‚ùå Erro ao processar pergunta: {str(e)}")

@bot.command(name=\'status\', help=\'Mostra o status do monitoramento\')
async def status(ctx):
    """Mostra o status do monitoramento"""
    guild_state = get_guild_state(ctx.guild.id)
    
    status_msg = f"üìä **Status do {guild_state.bot_name}**\n\n"
    status_msg += f"üé§ Canal de voz: {\'Conectado\' if guild_state.voice_client and guild_state.voice_client.is_connected() else \'Desconectado\'}\n"
    status_msg += f"üëÅÔ∏è Monitoramento: {\'Ativo ‚úÖ\' if guild_state.monitoring else \'Inativo ‚è∏Ô∏è\'}\n"
    
    connected_clients_count = len([t for t, info in ws_server.user_tokens.items() if info["guild_id"] == ctx.guild.id and t in ws_server.clients])
    status_msg += f"üîó Clientes locais conectados: {connected_clients_count}\n"
    
    await ctx.send(status_msg)

# Fun√ß√£o para obter PUUID de um nome de invocador
async def get_puuid_by_summoner_name(summoner_name: str, region: str = "br1"):
    if not RIOT_API_KEY:
        print("RIOT_API_KEY n√£o configurada.")
        return None
    
    # Primeiro, obter o summonerId
    summoner_url = f"https://{region}.api.riotgames.com/lol/summoner/v4/summoners/by-name/{summoner_name}?api_key={RIOT_API_KEY}"
    try:
        response = requests.get(summoner_url)
        response.raise_for_status() # Levanta exce√ß√£o para erros HTTP
        summoner_data = response.json()
        return summoner_data.get("puuid")
    except requests.exceptions.RequestException as e:
        print(f"Erro ao obter PUUID para {summoner_name}: {e}")
        return None

# Fun√ß√£o para obter match IDs
async def get_match_ids_by_puuid(puuid: str, count: int = 1, region_routing: str = "americas"):
    if not RIOT_API_KEY:
        print("RIOT_API_KEY n√£o configurada.")
        return []
    
    match_list_url = f"https://{region_routing}.api.riotgames.com/lol/match/v5/matches/by-puuid/{puuid}/ids?count={count}&api_key={RIOT_API_KEY}"
    try:
        response = requests.get(match_list_url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Erro ao obter match IDs para PUUID {puuid}: {e}")
        return []

# Fun√ß√£o para obter detalhes da partida
async def get_match_details(match_id: str, region_routing: str = "americas"):
    if not RIOT_API_KEY:
        print("RIOT_API_KEY n√£o configurada.")
        return None
    
    match_details_url = f"https://{region_routing}.api.riotgames.com/lol/match/v5/matches/{match_id}?api_key={RIOT_API_KEY}"
    try:
        response = requests.get(match_details_url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Erro ao obter detalhes da partida {match_id}: {e}")
        return None

# Fun√ß√£o para gerar relat√≥rio p√≥s-partida (agora no bot_cloud)
def generate_postgame_report(match_details: dict, player_puuid: str, bot_name: str) -> str:
    """Gera um relat√≥rio de an√°lise p√≥s-partida a partir dos detalhes da partida."""
    report = []

    # Carregar dados de itens para nomes
    item_data = {}
    try:
        item_file = os.path.join(os.path.dirname(__file__), "item.json")
        with open(item_file, "r", encoding="utf-8") as f:
            data = json.load(f)
            item_data = {item_id: item_info["name"] for item_id, item_info in data["data"].items()}
    except FileNotFoundError:
        print("Erro: item.json n√£o encontrado para an√°lise p√≥s-partida.")
    except Exception as e:
        print(f"Erro ao carregar dados de itens para an√°lise p√≥s-partida: {e}")

    # Encontrar o participante do jogador
    player_participant = None
    for participant in match_details["info"]["participants"]:
        if participant["puuid"] == player_puuid:
            player_participant = participant
            break

    if not player_participant:
        return "N√£o foi poss√≠vel encontrar os dados do jogador nesta partida."

    # Resumo da partida
    game_duration_seconds = match_details["info"]["gameDuration"]
    game_duration_minutes = round(game_duration_seconds / 60)
    game_mode = match_details["info"]["gameMode"]
    win = "Vit√≥ria" if player_participant["win"] else "Derrota"

    report.append(f"**Resultado:** {win} em {game_mode} ({game_duration_minutes} minutos)")
    report.append(f"**Campe√£o:** {player_participant["championName"]} ({player_participant["champLevel"]}) - KDA: {player_participant["kills"]}/{player_participant["deaths"]}/{player_participant["assists"]}")
    report.append(f"**Farm (CS):** {player_participant["totalMinionsKilled"]} + {player_participant["neutralMinionsKilled"]} (selva)")
    report.append(f"**Ouro:** {round(player_participant["goldEarned"] / 1000, 1)}k")
    report.append(f"**Dano Causado:** {player_participant["totalDamageDealtToChampions"]:,}")
    report.append(f"**Vis√£o:** {player_participant["visionScore"]}")

    # An√°lise de itens
    items_names = []
    for i in range(0, 7): # Itens de 0 a 6
        item_id = player_participant.get(f"item{i}")
        if item_id and item_id != 0:
            item_name = item_data.get(str(item_id), f"Item ID: {item_id}")
            items_names.append(item_name)
    if items_names:
        report.append(f"**Itens Finais:** {\", \".join(items_names)}")

    # Dicas baseadas em performance
    if player_participant["deaths"] > player_participant["kills"] + player_participant["assists"]:
        report.append("üí° **Dica:** Voc√™ teve muitas mortes em rela√ß√£o aos abates e assist√™ncias. Tente jogar de forma mais segura e evitar lutas desfavor√°veis.")
    elif player_participant["totalMinionsKilled"] < (game_duration_minutes * 5): # Exemplo: menos de 5 CS por minuto
        report.append("üí° **Dica:** Seu farm (CS) foi um pouco baixo. Focar em farmar mais pode te dar uma vantagem de ouro significativa.")
    
    if player_participant["visionScore"] < (game_duration_minutes * 1.5): # Exemplo: menos de 1.5 de vis√£o por minuto
        report.append("üí° **Dica:** Sua pontua√ß√£o de vis√£o foi um pouco baixa. Wards s√£o cruciais para controle de mapa e seguran√ßa.")

    # Dicas do LLM para an√°lise mais aprofundada
    try:
        openai_client = OpenAI()
        llm_prompt = f"Analise o seguinte desempenho de um jogador em uma partida de League of Legends e forne√ßa dicas construtivas e personalizadas. O jogador jogou de {player_participant["championName"]}. KDA: {player_participant["kills"]}/{player_participant["deaths"]}/{player_participant["assists"]}. Farm: {player_participant["totalMinionsKilled"]} + {player_participant["neutralMinionsKilled"]}. Ouro: {round(player_participant["goldEarned"] / 1000, 1)}k. Dano: {player_participant["totalDamageDealtToChampions"]:,}. Vis√£o: {player_participant["visionScore"]}. Itens: {\", \".join(items_names)}. A partida durou {game_duration_minutes} minutos e o resultado foi {win}. O que o jogador poderia ter feito melhor e quais s√£o 2-3 dicas acion√°veis para a pr√≥xima partida?" 
        
        llm_response = openai_client.chat.completions.create(
            model="gemini-2.5-flash",
            messages=[
                {"role": "system", "content": f"Voc√™ √© um treinador de League of Legends chamado {bot_name}. Forne√ßa an√°lises p√≥s-partida detalhadas e dicas construtivas. Use portugu√™s do Brasil."},
                {"role": "user", "content": llm_prompt}
            ],
            max_tokens=300
        )
        llm_tip = llm_response.choices[0].message.content
        report.append(f"\nüß† **An√°lise Avan√ßada do {bot_name}:**\n{llm_tip}")

    except Exception as e:
        print(f"Erro ao gerar an√°lise p√≥s-partida com LLM: {e}")
        report.append("\n‚ö†Ô∏è N√£o foi poss√≠vel gerar uma an√°lise avan√ßada no momento.")

    return "\n".join(report)

@bot.command(name=\'postgame\', help=\'Analisa a √∫ltima partida de um jogador (uso: !coach postgame NomeInvocador)\')
async def postgame_analysis(ctx, *, summoner_name: str):
    """Realiza a an√°lise p√≥s-partida para um jogador"""
    guild_state = get_guild_state(ctx.guild.id)
    await ctx.send(f"üîé {guild_state.bot_name} est√° analisando a √∫ltima partida de **{summoner_name}**... Isso pode levar um momento.")

    try:
        # 1. Obter PUUID do nome de invocador
        puuid = await get_puuid_by_summoner_name(summoner_name)
        if not puuid:
            await ctx.send(f"‚ùå {guild_state.bot_name} n√£o conseguiu encontrar o PUUID para **{summoner_name}**. Verifique o nome e a regi√£o (padr√£o: br1).")
            return

        # 2. Obter IDs das √∫ltimas partidas
        # Assumindo que a regi√£o de roteamento para BR √© \'americas\'
        match_ids = await get_match_ids_by_puuid(puuid, count=1, region_routing="americas")
        if not match_ids:
            await ctx.send(f"‚ùå {guild_state.bot_name} n√£o encontrou nenhuma partida recente para **{summoner_name}**.")
            return

        latest_match_id = match_ids[0]

        # 3. Obter detalhes da √∫ltima partida
        match_details = await get_match_details(latest_match_id, region_routing="americas")
        if not match_details:
            await ctx.send(f"‚ùå {guild_state.bot_name} n√£o conseguiu obter os detalhes da partida {latest_match_id}.")
            return

        # 4. Processar e gerar an√°lise
        analysis_report = generate_postgame_report(match_details, puuid, guild_state.bot_name)

        await ctx.send(f"‚úÖ **An√°lise P√≥s-Partida de {guild_state.bot_name} para {summoner_name} (Partida ID: {latest_match_id}):**\n\n{analysis_report}")

        if guild_state.voice_client and guild_state.voice_client.is_connected():
            await speak_text(guild_state, f"An√°lise p√≥s-partida para {summoner_name} conclu√≠da. Verifique o chat para o relat√≥rio completo.")

    except Exception as e:
        await ctx.send(f"‚ùå Ocorreu um erro durante a an√°lise p√≥s-partida: {str(e)}")

async def speak_text(guild_state: GuildState, text: str):
    """Converte texto em fala e reproduz no canal de voz do Discord"""
    if not guild_state.voice_client or not guild_state.voice_client.is_connected():
        return
    
    try:
        # Gerar √°udio usando gTTS
        tts = gTTS(text=text, lang='pt', slow=False)
        fp = io.BytesIO()
        tts.write_to_fp(fp)
        fp.seek(0)
        
        # Aguardar se j√° estiver falando
        while guild_state.voice_client.is_playing():
            await asyncio.sleep(0.1)
        
        # Reproduzir √°udio
        audio_source = discord.FFmpegPCMAudio(fp)
        guild_state.voice_client.play(audio_source)
        
        # Aguardar t√©rmino da reprodu√ß√£o
        while guild_state.voice_client.is_playing():
            await asyncio.sleep(0.1)
        
        fp.close()
    
    except Exception as e:
        print(f"Erro ao falar texto: {e}")

# Adicionar speak_text como m√©todo do bot para acesso do WebSocket server
bot.speak_text = speak_text

# Comandos de encerramento
@bot.command(name=\'shutdown\', help=\'Desliga o bot (apenas para usu√°rios autorizados)\'
)
async def shutdown(ctx):
    """Desliga o bot"""
    # Apenas o dono do bot pode deslig√°-lo
    if ctx.author.id == bot.owner_id:
        await ctx.send("üëã Desligando o treinador virtual. At√© a pr√≥xima!")
        await bot.close()
    else:
        await ctx.send("‚ùå Voc√™ n√£o tem permiss√£o para desligar o bot.")

# Executar o bot
if __name__ == "__main__":
    DISCORD_TOKEN = os.getenv("DISCORD_BOT_TOKEN")
    
    if not DISCORD_TOKEN:
        print("‚ùå ERRO: Token do Discord n√£o configurado!")
        print("Por favor, configure a vari√°vel de ambiente DISCORD_BOT_TOKEN")
        exit(1)
    
    # Obter o ID do dono do bot (para o comando shutdown)
    # Isso geralmente √© configurado no Discord Developer Portal
    # Ou pode ser o ID do usu√°rio que est√° executando o bot localmente
    bot.owner_id = int(os.getenv("DISCORD_OWNER_ID", 0)) # Defina DISCORD_OWNER_ID no .env

    print("üöÄ Iniciando o Treinador Virtual (Vers√£o Cloud)...")
    bot.run(DISCORD_TOKEN)

